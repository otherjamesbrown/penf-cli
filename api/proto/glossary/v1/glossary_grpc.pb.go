// Glossary Service Protobuf Definitions
// Provides gRPC service for managing terminology and query expansion

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: glossary/v1/glossary.proto

package glossaryv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GlossaryService_AddTerm_FullMethodName         = "/penfold.glossary.v1.GlossaryService/AddTerm"
	GlossaryService_GetTerm_FullMethodName         = "/penfold.glossary.v1.GlossaryService/GetTerm"
	GlossaryService_ListTerms_FullMethodName       = "/penfold.glossary.v1.GlossaryService/ListTerms"
	GlossaryService_UpdateTerm_FullMethodName      = "/penfold.glossary.v1.GlossaryService/UpdateTerm"
	GlossaryService_DeleteTerm_FullMethodName      = "/penfold.glossary.v1.GlossaryService/DeleteTerm"
	GlossaryService_ExpandQuery_FullMethodName     = "/penfold.glossary.v1.GlossaryService/ExpandQuery"
	GlossaryService_LookupTerm_FullMethodName      = "/penfold.glossary.v1.GlossaryService/LookupTerm"
	GlossaryService_LinkTerm_FullMethodName        = "/penfold.glossary.v1.GlossaryService/LinkTerm"
	GlossaryService_UnlinkTerm_FullMethodName      = "/penfold.glossary.v1.GlossaryService/UnlinkTerm"
	GlossaryService_ListLinkedTerms_FullMethodName = "/penfold.glossary.v1.GlossaryService/ListLinkedTerms"
)

// GlossaryServiceClient is the client API for GlossaryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// GlossaryService provides gRPC endpoints for managing glossary terms.
// Terms are used for query expansion during search to improve recall.
type GlossaryServiceClient interface {
	// AddTerm adds a new term to the glossary.
	AddTerm(ctx context.Context, in *AddTermRequest, opts ...grpc.CallOption) (*AddTermResponse, error)
	// GetTerm retrieves a term by ID or term string.
	GetTerm(ctx context.Context, in *GetTermRequest, opts ...grpc.CallOption) (*GetTermResponse, error)
	// ListTerms returns a filtered list of glossary terms.
	ListTerms(ctx context.Context, in *ListTermsRequest, opts ...grpc.CallOption) (*ListTermsResponse, error)
	// UpdateTerm updates an existing glossary term.
	UpdateTerm(ctx context.Context, in *UpdateTermRequest, opts ...grpc.CallOption) (*UpdateTermResponse, error)
	// DeleteTerm removes a term from the glossary.
	DeleteTerm(ctx context.Context, in *DeleteTermRequest, opts ...grpc.CallOption) (*DeleteTermResponse, error)
	// ExpandQuery expands a search query using glossary terms.
	ExpandQuery(ctx context.Context, in *ExpandQueryRequest, opts ...grpc.CallOption) (*ExpandQueryResponse, error)
	// LookupTerm looks up a specific term and returns its expansion.
	LookupTerm(ctx context.Context, in *LookupTermRequest, opts ...grpc.CallOption) (*LookupTermResponse, error)
	// LinkTerm links a glossary term to an entity (product, project, company).
	LinkTerm(ctx context.Context, in *LinkTermRequest, opts ...grpc.CallOption) (*LinkTermResponse, error)
	// UnlinkTerm removes the entity link from a glossary term.
	UnlinkTerm(ctx context.Context, in *UnlinkTermRequest, opts ...grpc.CallOption) (*UnlinkTermResponse, error)
	// ListLinkedTerms returns all terms linked to entities.
	ListLinkedTerms(ctx context.Context, in *ListLinkedTermsRequest, opts ...grpc.CallOption) (*ListLinkedTermsResponse, error)
}

type glossaryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGlossaryServiceClient(cc grpc.ClientConnInterface) GlossaryServiceClient {
	return &glossaryServiceClient{cc}
}

func (c *glossaryServiceClient) AddTerm(ctx context.Context, in *AddTermRequest, opts ...grpc.CallOption) (*AddTermResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddTermResponse)
	err := c.cc.Invoke(ctx, GlossaryService_AddTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *glossaryServiceClient) GetTerm(ctx context.Context, in *GetTermRequest, opts ...grpc.CallOption) (*GetTermResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTermResponse)
	err := c.cc.Invoke(ctx, GlossaryService_GetTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *glossaryServiceClient) ListTerms(ctx context.Context, in *ListTermsRequest, opts ...grpc.CallOption) (*ListTermsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTermsResponse)
	err := c.cc.Invoke(ctx, GlossaryService_ListTerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *glossaryServiceClient) UpdateTerm(ctx context.Context, in *UpdateTermRequest, opts ...grpc.CallOption) (*UpdateTermResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTermResponse)
	err := c.cc.Invoke(ctx, GlossaryService_UpdateTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *glossaryServiceClient) DeleteTerm(ctx context.Context, in *DeleteTermRequest, opts ...grpc.CallOption) (*DeleteTermResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTermResponse)
	err := c.cc.Invoke(ctx, GlossaryService_DeleteTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *glossaryServiceClient) ExpandQuery(ctx context.Context, in *ExpandQueryRequest, opts ...grpc.CallOption) (*ExpandQueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExpandQueryResponse)
	err := c.cc.Invoke(ctx, GlossaryService_ExpandQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *glossaryServiceClient) LookupTerm(ctx context.Context, in *LookupTermRequest, opts ...grpc.CallOption) (*LookupTermResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LookupTermResponse)
	err := c.cc.Invoke(ctx, GlossaryService_LookupTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *glossaryServiceClient) LinkTerm(ctx context.Context, in *LinkTermRequest, opts ...grpc.CallOption) (*LinkTermResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LinkTermResponse)
	err := c.cc.Invoke(ctx, GlossaryService_LinkTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *glossaryServiceClient) UnlinkTerm(ctx context.Context, in *UnlinkTermRequest, opts ...grpc.CallOption) (*UnlinkTermResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnlinkTermResponse)
	err := c.cc.Invoke(ctx, GlossaryService_UnlinkTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *glossaryServiceClient) ListLinkedTerms(ctx context.Context, in *ListLinkedTermsRequest, opts ...grpc.CallOption) (*ListLinkedTermsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLinkedTermsResponse)
	err := c.cc.Invoke(ctx, GlossaryService_ListLinkedTerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GlossaryServiceServer is the server API for GlossaryService service.
// All implementations must embed UnimplementedGlossaryServiceServer
// for forward compatibility.
//
// GlossaryService provides gRPC endpoints for managing glossary terms.
// Terms are used for query expansion during search to improve recall.
type GlossaryServiceServer interface {
	// AddTerm adds a new term to the glossary.
	AddTerm(context.Context, *AddTermRequest) (*AddTermResponse, error)
	// GetTerm retrieves a term by ID or term string.
	GetTerm(context.Context, *GetTermRequest) (*GetTermResponse, error)
	// ListTerms returns a filtered list of glossary terms.
	ListTerms(context.Context, *ListTermsRequest) (*ListTermsResponse, error)
	// UpdateTerm updates an existing glossary term.
	UpdateTerm(context.Context, *UpdateTermRequest) (*UpdateTermResponse, error)
	// DeleteTerm removes a term from the glossary.
	DeleteTerm(context.Context, *DeleteTermRequest) (*DeleteTermResponse, error)
	// ExpandQuery expands a search query using glossary terms.
	ExpandQuery(context.Context, *ExpandQueryRequest) (*ExpandQueryResponse, error)
	// LookupTerm looks up a specific term and returns its expansion.
	LookupTerm(context.Context, *LookupTermRequest) (*LookupTermResponse, error)
	// LinkTerm links a glossary term to an entity (product, project, company).
	LinkTerm(context.Context, *LinkTermRequest) (*LinkTermResponse, error)
	// UnlinkTerm removes the entity link from a glossary term.
	UnlinkTerm(context.Context, *UnlinkTermRequest) (*UnlinkTermResponse, error)
	// ListLinkedTerms returns all terms linked to entities.
	ListLinkedTerms(context.Context, *ListLinkedTermsRequest) (*ListLinkedTermsResponse, error)
	mustEmbedUnimplementedGlossaryServiceServer()
}

// UnimplementedGlossaryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGlossaryServiceServer struct{}

func (UnimplementedGlossaryServiceServer) AddTerm(context.Context, *AddTermRequest) (*AddTermResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTerm not implemented")
}
func (UnimplementedGlossaryServiceServer) GetTerm(context.Context, *GetTermRequest) (*GetTermResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTerm not implemented")
}
func (UnimplementedGlossaryServiceServer) ListTerms(context.Context, *ListTermsRequest) (*ListTermsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTerms not implemented")
}
func (UnimplementedGlossaryServiceServer) UpdateTerm(context.Context, *UpdateTermRequest) (*UpdateTermResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTerm not implemented")
}
func (UnimplementedGlossaryServiceServer) DeleteTerm(context.Context, *DeleteTermRequest) (*DeleteTermResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTerm not implemented")
}
func (UnimplementedGlossaryServiceServer) ExpandQuery(context.Context, *ExpandQueryRequest) (*ExpandQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExpandQuery not implemented")
}
func (UnimplementedGlossaryServiceServer) LookupTerm(context.Context, *LookupTermRequest) (*LookupTermResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupTerm not implemented")
}
func (UnimplementedGlossaryServiceServer) LinkTerm(context.Context, *LinkTermRequest) (*LinkTermResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkTerm not implemented")
}
func (UnimplementedGlossaryServiceServer) UnlinkTerm(context.Context, *UnlinkTermRequest) (*UnlinkTermResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlinkTerm not implemented")
}
func (UnimplementedGlossaryServiceServer) ListLinkedTerms(context.Context, *ListLinkedTermsRequest) (*ListLinkedTermsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLinkedTerms not implemented")
}
func (UnimplementedGlossaryServiceServer) mustEmbedUnimplementedGlossaryServiceServer() {}
func (UnimplementedGlossaryServiceServer) testEmbeddedByValue()                         {}

// UnsafeGlossaryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GlossaryServiceServer will
// result in compilation errors.
type UnsafeGlossaryServiceServer interface {
	mustEmbedUnimplementedGlossaryServiceServer()
}

func RegisterGlossaryServiceServer(s grpc.ServiceRegistrar, srv GlossaryServiceServer) {
	// If the following call pancis, it indicates UnimplementedGlossaryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GlossaryService_ServiceDesc, srv)
}

func _GlossaryService_AddTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTermRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).AddTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_AddTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).AddTerm(ctx, req.(*AddTermRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlossaryService_GetTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTermRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).GetTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_GetTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).GetTerm(ctx, req.(*GetTermRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlossaryService_ListTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).ListTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_ListTerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).ListTerms(ctx, req.(*ListTermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlossaryService_UpdateTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTermRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).UpdateTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_UpdateTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).UpdateTerm(ctx, req.(*UpdateTermRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlossaryService_DeleteTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTermRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).DeleteTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_DeleteTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).DeleteTerm(ctx, req.(*DeleteTermRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlossaryService_ExpandQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpandQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).ExpandQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_ExpandQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).ExpandQuery(ctx, req.(*ExpandQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlossaryService_LookupTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupTermRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).LookupTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_LookupTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).LookupTerm(ctx, req.(*LookupTermRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlossaryService_LinkTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkTermRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).LinkTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_LinkTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).LinkTerm(ctx, req.(*LinkTermRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlossaryService_UnlinkTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlinkTermRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).UnlinkTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_UnlinkTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).UnlinkTerm(ctx, req.(*UnlinkTermRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlossaryService_ListLinkedTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLinkedTermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlossaryServiceServer).ListLinkedTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlossaryService_ListLinkedTerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlossaryServiceServer).ListLinkedTerms(ctx, req.(*ListLinkedTermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GlossaryService_ServiceDesc is the grpc.ServiceDesc for GlossaryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GlossaryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "penfold.glossary.v1.GlossaryService",
	HandlerType: (*GlossaryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTerm",
			Handler:    _GlossaryService_AddTerm_Handler,
		},
		{
			MethodName: "GetTerm",
			Handler:    _GlossaryService_GetTerm_Handler,
		},
		{
			MethodName: "ListTerms",
			Handler:    _GlossaryService_ListTerms_Handler,
		},
		{
			MethodName: "UpdateTerm",
			Handler:    _GlossaryService_UpdateTerm_Handler,
		},
		{
			MethodName: "DeleteTerm",
			Handler:    _GlossaryService_DeleteTerm_Handler,
		},
		{
			MethodName: "ExpandQuery",
			Handler:    _GlossaryService_ExpandQuery_Handler,
		},
		{
			MethodName: "LookupTerm",
			Handler:    _GlossaryService_LookupTerm_Handler,
		},
		{
			MethodName: "LinkTerm",
			Handler:    _GlossaryService_LinkTerm_Handler,
		},
		{
			MethodName: "UnlinkTerm",
			Handler:    _GlossaryService_UnlinkTerm_Handler,
		},
		{
			MethodName: "ListLinkedTerms",
			Handler:    _GlossaryService_ListLinkedTerms_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "glossary/v1/glossary.proto",
}
